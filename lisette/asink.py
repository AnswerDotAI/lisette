"""Implements an `AsyncChat` version that mirrors the regular `lisette.Chat` as closely as possible."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_async.ipynb.

# %% auto 0
__all__ = ['AsyncStreamResult', 'AsyncChat']

# %% ../nbs/01_async.ipynb 2
import json,asyncio
from litellm import acompletion, ModelResponse, stream_chunk_builder
from toolslm.funccall import call_func_async
from fastcore.utils import *
from .core import *

# %% ../nbs/01_async.ipynb 4
async def _lite_call_func_async(tc, ns, raise_on_err=True):
    res = await call_func_async(tc.function.name, json.loads(tc.function.arguments), ns=ns)
    return {"tool_call_id": tc.id, "role": "tool", "name": tc.function.name, "content": str(res)}

# %% ../nbs/01_async.ipynb 5
class AsyncStreamResult:
    def __init__(self, agen, postproc=noop):
        self.agen = agen
        self.postproc = postproc
        self.complete = None
        
    async def __aiter__(self):
        chunks = []
        async for chunk in self.agen:
            chunks.append(chunk)
            yield chunk
        self.postproc(chunks)
        self.complete = stream_chunk_builder(chunks)

# %% ../nbs/01_async.ipynb 6
class AsyncChat(Chat):
    async def _call(self, msg=None, stream=False, max_tool_rounds=1, tool_round=0, final_prompt=None, tool_choice=None, **kwargs):
        "Internal method that always yields responses"
        msgs = self._prepare_msgs(msg)
        res = await acompletion(model=self.model, messages=msgs, stream=stream,
                         tools=self.tool_schemas, temperature=self.temp, **kwargs)
        if stream:
            res = AsyncStreamResult(res, postproc=cite_footnotes)
            async for chunk in res: yield chunk
            res = res.complete
        
        yield res
        m = res.choices[0].message
        self.hist.append(m)

        if tcs := m.tool_calls:
            tool_results = [await _lite_call_func_async(tc, ns=self.ns) for tc in tcs]
            if tool_round>=max_tool_rounds-1:
                tool_results += ([{"role": "user", "content": final_prompt}] if final_prompt else [])
                tool_choice='none'
            async for result in self._call(
                tool_results, stream, max_tool_rounds, tool_round+1,
                final_prompt, tool_choice=tool_choice, **kwargs):
                    yield result
    
    async def __call__(self, msg=None, stream=False, max_tool_rounds=1, final_prompt=None, return_all=False, **kwargs):
        "Main call method - handles streaming vs non-streaming"
        if stream: return self._call(msg, stream, max_tool_rounds, 0, final_prompt, **kwargs)
        result_gen = self._call(msg, stream, max_tool_rounds, 0, final_prompt, **kwargs)
        if return_all: return [result async for result in result_gen] # toolloop behavior
        else: return [result async for result in result_gen][-1]      # normal chat behavior
